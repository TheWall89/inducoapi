#!/usr/bin/env python3

#  Copyright 2020 Matteo Pergolesi <matpergo [at] gmail [dot] com>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import argparse
import json
from json import JSONDecodeError
from typing import Dict, Tuple, Any, Union, List, Optional

import yaml
from openapi3 import OpenAPI
from openapi3.errors import SpecError

_example = True


class NoAliasDumper(yaml.Dumper):
    def ignore_aliases(self, data):
        return True


def _get_type_ex(val: Any) -> Tuple[str, Any]:
    ex = val
    if val is None:
        # If no value is provided, assume string
        t = "string"
        ex = ""
    elif isinstance(val, str):
        t = "string"
    elif isinstance(val, int):
        t = "integer"
    elif isinstance(val, float):
        t = "number"
    elif isinstance(val, bool):
        t = "boolean"
    else:
        t = ""
        print("Unknown type: {}, value: {}".format(type(val), val))

    global _example
    if _example:
        return {"type": t, "example": ex}
    else:
        return {"type": t}


def _gen_schema(data: Union[Dict, List]) -> Dict:
    if isinstance(data, dict):
        schema = {
            "type": "object",
            "properties": {}
        }
        for key, val in data.items():
            schema["properties"][key] = _gen_schema(val)
    elif isinstance(data, list):
        schema = {
            "type": "array",
            "items": {}
        }
        if data:
            schema["items"] = _gen_schema(data[0])
    else:
        schema = _get_type_ex(data)
    return schema


def _load_file(file: str) -> Optional[Dict]:
    with open(file) as f:
        try:
            return json.load(f)
        except JSONDecodeError:
            f.seek(0)
            try:
                return yaml.safe_load(f)
            except yaml.YAMLError:
                return None


def _get_parser():
    descr = "A simple python program to generate OpenApi documentation by " \
            "supplying request/response bodies"
    fmt = argparse.ArgumentDefaultsHelpFormatter
    usage = "%(prog)s METHOD PATH CODE [options]"
    p = argparse.ArgumentParser("json2openapi.py", description=descr,
                                usage=usage, formatter_class=fmt)
    p.add_argument("method", type=str,
                   choices=["GET", "POST", "PUT", "PATCH", "DELETE"],
                   metavar="METHOD",
                   help="HTTP request method")
    p.add_argument("path", type=str, metavar="PATH",
                   help="URI path")
    p.add_argument("resp_code", type=int, metavar="CODE",
                   help="HTTP response code")
    p.add_argument("--request", type=str, metavar="PATH",
                   help="Path to file containing request body")
    p.add_argument("--response", type=str, metavar="PATH",
                   help="Path to file containing response body")
    p.add_argument("--output", type=str, metavar="PATH",
                   help="Path to output file")
    p.add_argument("--no-example", "-ne", dest="example", default=True,
                   action="store_false",
                   help="Do not generate schema examples")
    p.add_argument("--media-type", type=str, default="application/json",
                   metavar="STR",
                   help="Desired media type to be used")
    return p


def build_openapi(method: str, path: str, resp_code: int, request: str = None,
    response: str = None, media_type: str = "application/json") -> Dict:
    oapi = {
        "openapi": "3.0.0",
        "info": {
            "title": "Generated by json2openapi",
            "version": "v1",
        },
        "paths": {
            path: {
                method.lower(): {
                    "requestBody": None,
                    "responses": {
                        resp_code: {
                            "description": "",
                        }
                    }
                }
            }
        }
    }
    if request:
        request_load = _load_file(request)
        if request_load:
            oapi["paths"][path][method.lower()]["requestBody"] = {
                "content": {
                    media_type: {
                        "schema": _gen_schema(request_load)
                    }
                }
            }
        else:
            print("Warning: {} looks not valid, skip request generation".
                  format(request))
    else:
        del oapi["paths"][path][method.lower()]["requestBody"]

    if response:
        response_load = _load_file(response)
        if response_load:
            oapi["paths"][path][method.lower()]["responses"][
                resp_code]["content"] = {
                media_type: {
                    "schema": _gen_schema(response_load)
                }
            }
        else:
            print("Warning: {} looks not valid, skip response generation".
                  format(response))
    return oapi


def main():
    args = _get_parser().parse_args()
    global _example
    _example = args.example

    oapi = build_openapi(args.method, args.path, args.resp_code,
                         request=args.request, response=args.response,
                         media_type=args.media_type)

    try:
        OpenAPI(oapi)
    except SpecError as e:
        print("OpenApi validation error! {}".format(e.message))
        return

    if args.output:
        with open(args.output, "w") as o:
            yaml.dump(oapi, o, indent=2, Dumper=NoAliasDumper, sort_keys=False)
        print("Output written to {}".format(args.output))
    else:
        print(yaml.dump(oapi, indent=2, Dumper=NoAliasDumper, sort_keys=False))


if __name__ == '__main__':
    main()
